use ndarray::{Array1, ArrayViewMut, Ix1};
use std::f32::consts::PI;

fn blackman_window(n: f32, m: f32) -> f32 {
    // blackman window as implemented by numpy (python)
    let res = 0.42 - 0.5 * (2.0 * PI * n / m).cos() + 0.08 * (4.0 * PI * n / m).cos();
    if res.is_nan() {
        1.0
    } else {
        res.clamp(0.0, 1.0)
    }
}

pub fn apply_fft_window(
    signal: &mut ArrayViewMut<f32, Ix1>,
    time: &Array1<f32>,
    lower_bound: &f32,
    upper_bound: &f32,
) {
    for (s, t) in signal.iter_mut().zip(time.iter()) {
        if *t <= lower_bound + time[0] {
            // first half of blackman
            let bw = blackman_window(t - time[0], 2.0 * lower_bound);
            *s *= bw;
        } else if *t >= time[time.len() - 1] - upper_bound {
            // second half of blackman
            let bw = blackman_window(
                t - (time[time.len() - 1] - upper_bound * 2.0),
                2.0 * upper_bound,
            );
            *s *= bw;
        }
    }
}

pub fn numpy_unwrap(x: &[f32], period: Option<f32>) -> Vec<f32> {
    // this was generated by ChatGPT

    let period = period.unwrap_or_else(|| {
        let diff = x[1..]
            .iter()
            .zip(x.iter())
            .map(|(&a, &b)| a - b)
            .collect::<Vec<f32>>();
        let diff_mean = diff.iter().sum::<f32>() / diff.len() as f32;
        2.0 * std::f32::consts::PI / diff_mean
    });
    let mut unwrapped = x.to_owned();
    let mut prev_val = x[0];
    let mut prev_unwrapped = x[0];
    for i in 1..x.len() {
        let val = x[i];
        let mut diff = val - prev_val;
        if diff > period / 2.0 {
            diff -= period;
        } else if diff < -period / 2.0 {
            diff += period;
        }
        let unwrapped_val = prev_unwrapped + diff;
        prev_val = val;
        prev_unwrapped = unwrapped_val;
        unwrapped[i] = unwrapped_val;
    }
    unwrapped
}
