use std::cmp::{max, min};
use std::f64::consts::PI;

use itertools_num::linspace;
use rand::Rng;
use rayon::prelude::*;
use realfft::num_complex::Complex64;
use realfft::RealFftPlanner;

use crate::data::DataContainer;

fn blackman_window(n: f64, m: f64) -> f64 {
    // blackman window as implemented by numpy (python)
    let res = 0.42 - 0.5 * (2.0 * PI * n / m).cos() + 0.08 * (4.0 * PI * n / m).cos();
    return if res.is_nan() {
        1.0
    } else if res < 0.0 {
        0.0
    } else if res > 1.0 {
        1.0
    } else {
        res
    };
}

pub fn apply_fft_window(signal: &mut [f64], time: &[f64], lower_bound: &f64, upper_bound: &f64) {
    for (s, t) in signal.iter_mut().zip(time.iter()) {
        if *t <= lower_bound + time[0] {
            // first half of blackman
            let bw = blackman_window(t - time[0], 2.0 * lower_bound);
            *s *= bw;
        } else if *t >= time[time.len() - 1] - upper_bound {
            // second half of blackman
            let bw = blackman_window(
                t - (time[time.len() - 1] - upper_bound * 2.0),
                2.0 * upper_bound,
            );
            *s *= bw;
        }
    }
}

pub fn apply_filter(data: &mut DataContainer, bounds: &[f64; 2]) {
    for ((f, amplitude), filtered_amplitude) in data
        .frequencies_fft
        .iter()
        .zip(data.signal_1_fft.iter())
        .zip(data.filtered_signal_1_fft.iter_mut())
    {
        if (*f >= bounds[0]) && (*f <= bounds[1]) {
            *filtered_amplitude = *amplitude;
        } else {
            *filtered_amplitude = 0.0;
        }
    }
}

pub fn make_fft(
    t_in: &[f64],
    p_in: &[f64],
    normalize: bool,
    df: &f64,
    lower_bound: &f64,
    upper_bound: &f64,
) -> (Vec<f64>, Vec<f64>, Vec<f64>) {
    // make a planner
    let mut real_planner = RealFftPlanner::<f64>::new();

    // implement zero padding!
    let dt = t_in[1] - t_in[0];
    let zero_padding = (1.0 / (*df * dt)) as usize;
    let padding_length;
    let mut t = t_in.to_vec();
    let mut p = p_in.to_vec();

    // apply fft window (modified blackman window as specified by Toptica)
    apply_fft_window(&mut p, &t, lower_bound, upper_bound);

    if zero_padding > t.len() {
        padding_length = zero_padding - t.len();
        let t_padded_bound = t[0] + dt * (zero_padding as f64);
        t = linspace::<f64>(t[0], t_padded_bound, zero_padding).collect();
        p.append(&mut vec![0.0; padding_length]);
    }

    // create a FFT
    let r2c = real_planner.plan_fft_forward(t.len());
    // make input and output vectors
    let mut in_data: Vec<f64> = p.par_iter().map(|x| *x as f64).collect();
    let mut spectrum = r2c.make_output_vec();
    // Forward transform the input data
    r2c.process(&mut in_data, &mut spectrum).unwrap();

    // println!("spectrum: {:?}", spectrum);

    let mut amp: Vec<f64> = spectrum.par_iter().map(|s| s.norm()).collect();
    let rng = t[t.len() - 1] - t[0];
    let freq: Vec<f64> = (0..spectrum.len()).map(|i| i as f64 / rng).collect();
    let phase: Vec<f64> = spectrum.par_iter().map(|s| s.arg()).collect();
    if normalize {
        let max_amp = amp.iter().fold(f64::NEG_INFINITY, |ai, &bi| ai.max(bi));
        amp = amp.par_iter().map(|a| *a / max_amp).collect();
    }
    (freq, amp, numpy_unwrap(phase, Some(2.0 * PI)))
}

pub fn make_ifft(frequencies: &[f64], amplitudes: &[f64], phases: &[f64]) -> Vec<f64> {
    // make a planner
    let mut real_planner = RealFftPlanner::<f64>::new();

    let mut spectrum: Vec<Complex64> = vec![];
    // spectrum = spectrum.iter_mut().zip(amplitudes.iter().zip(phases.iter()))
    //     .map(|(s,(a,p))| {
    //         *s = Complex64::new(*a,*p)
    //     }).collect();
    for (a, p) in amplitudes.iter().zip(phases.iter()) {
        spectrum.push(Complex64::from_polar(*a, *p));
    }

    // create a iFFT
    let c2r = real_planner.plan_fft_inverse((frequencies.len() - 1) * 2);
    // make input and output vectors
    let mut output = c2r.make_output_vec();

    // Forward transform the input data
    match c2r.process(&mut spectrum, &mut output) {
        Ok(_) => {}
        Err(_) => {
            //println!("error in iFFT: {err:?}");
        }
    };
    let length = output.len();
    output = output.par_iter().map(|p| *p / length as f64).collect();
    // let mut pulse: Vec<f64> = vec![];
    // for (i, p) in output.iter().enumerate() {
    //     if i % 2 == 0 {
    //         pulse.push(*p)
    //     }
    // };
    output
}

fn numpy_unwrap(mut phase_unwrapped: Vec<f64>, discont: Option<f64>) -> Vec<f64> {
    // this was generated by ChatGPT

    let n = phase_unwrapped.len();

    if n == 0 {
        return phase_unwrapped;
    }

    if let Some(discontinuity) = discont {
        let mut jump = 0.0;
        for i in 1..n {
            let delta = phase_unwrapped[i] - phase_unwrapped[i - 1] - jump;
            if delta > discontinuity {
                jump += -2.0 * PI;
            } else if delta < -discontinuity {
                jump += 2.0 * PI;
            }
            phase_unwrapped[i] += jump;
        }
    } else {
        let mut prev_phase = phase_unwrapped[0];
        for phase in phase_unwrapped.iter_mut() {
            let mut diff = *phase - prev_phase;
            while diff > PI {
                diff -= 2.0 * PI;
            }
            while diff <= -PI {
                diff += 2.0 * PI;
            }
            *phase = prev_phase + diff;
            prev_phase = *phase;
        }
    }

    phase_unwrapped
}

#[cfg(test)]
mod tests {
    use approx::assert_relative_eq;
    use std::path::PathBuf;

    use crate::io::{open_from_csv, open_from_npy};

    // Note this useful idiom: importing names from outer (for mod tests) scope.
    use super::*;

    #[test]
    fn test_fft_ifft() {
        let path = PathBuf::from("pixel_ID=00000-00000.npy");
        let fft_path = PathBuf::from("pixel_ID=00000-00000_spectrum.npy");
        let mut data = DataContainer::default();

        open_from_npy(&mut data, &path, &fft_path).expect("TODO: panic message");

        println!("signal: {:?}", data.signal_1[100]);

        let mut spectrum: Vec<Complex64> = vec![];
        for (a, p) in data.signal_1_fft.iter().zip(data.phase_1_fft.iter()) {
            spectrum.push(Complex64::from_polar(*a, *p));
        }

        println!("spectrum: {:?}", spectrum[100]);

        let (frequencies_fft, signal_1_fft, phase_1_fft) =
            make_fft(&data.time, &data.signal_1, false, &0.001, &1.0, &7.0);

        data.frequencies_fft = frequencies_fft;
        data.signal_1_fft = signal_1_fft;
        data.phase_1_fft = phase_1_fft;

        let mut spectrum: Vec<Complex64> = vec![];
        for (a, p) in data.signal_1_fft.iter().zip(data.phase_1_fft.iter()) {
            spectrum.push(Complex64::from_polar(*a, *p));
        }

        println!("spectrum: {:?}", spectrum[100]);

        data.filtered_signal_1 =
            make_ifft(&data.frequencies_fft, &data.signal_1_fft, &data.phase_1_fft);

        println!("signal: {:?}", data.filtered_signal_1[100]);
    }

    #[test]
    fn one_dim_fft() {
        // data([f64;6])
        let answer = vec![0, 1, 2, 3, 2, 1, 0]
            .into_iter()
            .map(|x| x as f64)
            .collect::<Vec<_>>();
        let mut fft_planner = realfft::RealFftPlanner::new();

        // fft
        let mut complex = {
            let fft = fft_planner.plan_fft_forward(answer.len());
            let mut f = answer.clone();
            let mut complex = fft.make_output_vec();
            fft.process(&mut f, &mut complex).unwrap();
            complex
        };

        // inv-fft
        let real = {
            let inv_fft = fft_planner.plan_fft_inverse(answer.len());
            let mut f = inv_fft.make_output_vec();
            inv_fft.process(&mut complex, &mut f).unwrap();
            let len = f.len();
            let f = f.into_iter().map(|x| x / len as f64).collect::<Vec<_>>();
            f
        };

        // test
        assert_eq!(answer.len(), real.len());
        const APPROX_EPSILON: f64 = 1e-15;
        for (ans, f) in answer.into_iter().zip(real) {
            println!("{ans} {f}");
            assert_relative_eq!(ans, f, epsilon = APPROX_EPSILON)
        }
    }
}
