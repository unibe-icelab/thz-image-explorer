use ndarray::{Array1, ArrayViewMut, Ix1, Zip};
use std::f32::consts::PI;
use std::fmt::{Display, Formatter};

#[derive(PartialEq, Clone, Copy)]
pub enum FftWindowType {
    AdaptedBlackman,
    Blackman,
    Hanning,
    Haming,
    FlatTop,
}

impl Display for FftWindowType {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        match self {
            FftWindowType::AdaptedBlackman => {
                write!(f, "Adapted Blackman")
            }
            FftWindowType::Blackman => {
                write!(f, "Blackman")
            }
            FftWindowType::Hanning => {
                write!(f, "Hanning")
            }
            FftWindowType::Haming => {
                write!(f, "Haming")
            }
            FftWindowType::FlatTop => {
                write!(f, "Flat Top")
            }
        }
    }
}

fn blackman_window(n: f32, m: f32) -> f32 {
    // blackman window as implemented by numpy (python)
    let res = 0.42 - 0.5 * (2.0 * PI * n / m).cos() + 0.08 * (4.0 * PI * n / m).cos();
    if res.is_nan() {
        1.0
    } else {
        res.clamp(0.0, 1.0)
    }
}

pub fn apply_adapted_blackman_window(
    signal: &mut ArrayViewMut<f32, Ix1>,
    time: &Array1<f32>,
    lower_bound: &f32,
    upper_bound: &f32,
) {
    for (s, t) in signal.iter_mut().zip(time.iter()) {
        if *t <= lower_bound + time[0] {
            // first half of blackman
            let bw = blackman_window(t - time[0], 2.0 * lower_bound);
            *s *= bw;
        } else if *t >= time[time.len() - 1] - upper_bound {
            // second half of blackman
            let bw = blackman_window(
                t - (time[time.len() - 1] - upper_bound * 2.0),
                2.0 * upper_bound,
            );
            *s *= bw;
        }
    }
}
/// Normalizes time array to range [0, 1]
fn normalize_time(time: &Array1<f32>) -> Array1<f32> {
    let min = time.iter().fold(f32::INFINITY, |a, &b| a.min(b)); // Find the minimum value
    let max = time.iter().fold(f32::NEG_INFINITY, |a, &b| a.max(b)); // Find the maximum value
    time.mapv(|t| (t - min) / (max - min))
}

/// Applies the Hamming window to the given signal.
///
/// # Arguments
/// - `signal`: The mutable view of the signal to which the window is applied.
/// - `time`: The time array (e.g., [1000.0, 1000.25, ..., 1050.0]).
pub fn apply_hamming(signal: &mut ArrayViewMut<f32, ndarray::Ix1>, time: &Array1<f32>) {
    let normalized_time = normalize_time(time);
    Zip::from(signal).and(&normalized_time).for_each(|s, t| {
        *s *= 0.54 - 0.46 * (2.0 * PI * t).cos();
    });
}

/// Applies the Hanning (Hann) window to the given signal.
///
/// # Arguments
/// - `signal`: The mutable view of the signal to which the window is applied.
/// - `time`: The time array (e.g., [1000.0, 1000.25, ..., 1050.0]).
pub fn apply_hanning(signal: &mut ArrayViewMut<f32, ndarray::Ix1>, time: &Array1<f32>) {
    let normalized_time = normalize_time(time);
    Zip::from(signal).and(&normalized_time).for_each(|s, t| {
        *s *= 0.5 * (1.0 - (2.0 * PI * t).cos());
    });
}

/// Applies the Blackman window to the given signal.
///
/// # Arguments
/// - `signal`: The mutable view of the signal to which the window is applied.
/// - `time`: The time array (e.g., [1000.0, 1000.25, ..., 1050.0]).
pub fn apply_blackman(signal: &mut ArrayViewMut<f32, ndarray::Ix1>, time: &Array1<f32>) {
    let normalized_time = normalize_time(time);
    Zip::from(signal).and(&normalized_time).for_each(|s, t| {
        *s *= 0.42 - 0.5 * (2.0 * PI * t).cos() + 0.08 * (4.0 * PI * t).cos();
    });
}

/// Applies the Flat Top window to the given signal.
///
/// # Arguments
/// - `signal`: The mutable view of the signal to which the window is applied.
/// - `time`: The time array (e.g., [1000.0, 1000.25, ..., 1050.0]).
pub fn apply_flat_top(signal: &mut ArrayViewMut<f32, ndarray::Ix1>, time: &Array1<f32>) {
    let normalized_time = normalize_time(time);
    Zip::from(signal).and(&normalized_time).for_each(|s, t| {
        *s *= 1.0 - 1.93 * (2.0 * PI * t).cos() + 1.29 * (4.0 * PI * t).cos()
            - 0.388 * (6.0 * PI * t).cos()
            + 0.028 * (8.0 * PI * t).cos();
    });
}
pub fn numpy_unwrap(x: &[f32], period: Option<f32>) -> Vec<f32> {
    // this was generated by ChatGPT

    let period = period.unwrap_or_else(|| {
        let diff = x[1..]
            .iter()
            .zip(x.iter())
            .map(|(&a, &b)| a - b)
            .collect::<Vec<f32>>();
        let diff_mean = diff.iter().sum::<f32>() / diff.len() as f32;
        2.0 * std::f32::consts::PI / diff_mean
    });
    let mut unwrapped = x.to_owned();
    let mut prev_val = x[0];
    let mut prev_unwrapped = x[0];
    for i in 1..x.len() {
        let val = x[i];
        let mut diff = val - prev_val;
        if diff > period / 2.0 {
            diff -= period;
        } else if diff < -period / 2.0 {
            diff += period;
        }
        let unwrapped_val = prev_unwrapped + diff;
        prev_val = val;
        prev_unwrapped = unwrapped_val;
        unwrapped[i] = unwrapped_val;
    }
    unwrapped
}
